def merge_sort(arr):
if len(arr) > 1:
mid = len(arr) // 2
left_half = arr[:mid]
right_half = arr [mid:]
merge_sort (left_half) merge_sort(right_half)
merge(arr, left_half, right_half)
return arr
13 v def merge(arr, left_half, right_half):
i =j= k = 0
while i ‹ len(left_half) and j < len(right_half):
if left_halfli] < right_halfljl:
arrik] = left_halflil
1 += 1
else:
arr|k] = right_halfljl
j += 1
k += 1
while i ‹ len (left_half):
arr|k] = left_halflil
i += 1
k += 1
while j < len (right_half):
arr[k] = right_half[jl
] += 1
k += 1
array = 17, 38, 27, 43, 3, 9, 82, 10]
sorted_arr = merge_sort(array)
print("Arreglo ordenado:", sorted_arr)

def quick_sort(arr):
if len(arr) <= 1:
return arr # Caso base: listas de 0 o 1 elementos ya están ordenadas
pivot = arr[len(arr) // 2] # Selecciona el pivote (aquí usamos el elemento centri
left = Ix for x in arr if x ‹ pivot]
# Elementos menores al pivote
middle = [x for x in arr if x == pivot] # Elementos iguales al pivote
right = [x for x in arr if x › pivotl # Elementos mayores al pivote
return quick_sort(left) + middle + quick_sort(right) # Llamadas recursivas
# Ejemplo de uso:
arr = 17, 38, 27, 43, 3, 9, 82, 101
sorted_arr = quick_sort(arr)
print("Arreglo ordenado:", sorted_arr)