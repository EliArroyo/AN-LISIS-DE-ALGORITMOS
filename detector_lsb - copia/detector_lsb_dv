import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import time
from scipy.stats import chisquare, entropy
import string

# ===============================================================
# CLASE PRINCIPAL DEL DETECTOR
# ===============================================================
class LSBDetectorDVC:
    def __init__(self, image_path, min_region_size=16, suspicion_threshold=0.5):
        self.image_path = image_path
        self.image = np.array(Image.open(image_path).convert("RGB"))
        self.min_region_size = min_region_size
        self.suspicion_threshold = suspicion_threshold
        self.cache = {}
        self.hotspots = []
        self.results = []

    # ---------------------------------------------------------------
    def dividir_y_analizar(self, x, y, w, h, channel=0):
        """Divide recursivamente la imagen y analiza regiones sospechosas"""
        key = (x, y, w, h, channel)
        if key in self.cache:
            return self.cache[key]

        region = self.image[y:y+h, x:x+w, channel]
        suspicion_score = self.analyze_region(region)

        # Si la región es pequeña o no sospechosa, detener
        if w <= self.min_region_size or h <= self.min_region_size or suspicion_score < self.suspicion_threshold:
            self.cache[key] = {"score": suspicion_score}
            if suspicion_score >= self.suspicion_threshold:
                self.hotspots.append((x, y, w, h, suspicion_score))
            return self.cache[key]

        # Dividir región en 4 subregiones
        mid_w, mid_h = w // 2, h // 2
        self.dividir_y_analizar(x, y, mid_w, mid_h, channel)
        self.dividir_y_analizar(x + mid_w, y, w - mid_w, mid_h, channel)
        self.dividir_y_analizar(x, y + mid_h, mid_w, h - mid_h, channel)
        self.dividir_y_analizar(x + mid_w, y + mid_h, w - mid_w, h - mid_h, channel)

        return {"score": suspicion_score}

    # ---------------------------------------------------------------
    def analyze_region(self, region):
        """Aplica pruebas estadísticas a una región"""
        bits = region & 1
        unique, counts = np.unique(bits, return_counts=True)
        if len(unique) < 2:
            return 0.0

        expected = [np.mean(counts)] * 2
        chi, _ = chisquare(counts, expected)
        p_value = np.exp(-chi / 2)

        ent = entropy(counts)
        balance = abs(counts[0] - counts[1]) / np.sum(counts)
        score = (1 - p_value) * 0.4 + ent * 0.3 + (1 - balance) * 0.3
        return min(score, 1.0)

    # ---------------------------------------------------------------
    def suspicion_heatmap(self, channel=0):
        """Genera mapa de calor"""
        h, w, _ = self.image.shape
        heatmap = np.zeros((h, w))
        for (x, y, rw, rh, score) in self.hotspots:
            heatmap[y:y+rh, x:x+rw] = score
        return heatmap

    # ---------------------------------------------------------------
    def plot_results(self, channel_name="R", display=True):
        """Muestra resultados del análisis"""
        heatmap = self.suspicion_heatmap()
        plt.figure(figsize=(8, 8))
        plt.imshow(self.image)
        plt.imshow(heatmap, cmap='jet', alpha=0.4)
        for (x, y, w, h, score) in self.hotspots:
            plt.gca().add_patch(plt.Rectangle((x, y), w, h, fill=False, edgecolor='lime', linewidth=1.5))
        plt.title(f"Mapa de sospecha LSB - Canal {channel_name}")
        if display:
            plt.show()

    # ---------------------------------------------------------------
    def analyze_all_channels(self, x=0, y=0):
        """Analiza automáticamente los tres canales RGB"""
        if self.image is None:
            print("No hay imagen cargada")
            return None

        h, w, _ = self.image.shape
        results = {}
        print("\nComparando canales...")
        for ch, name in enumerate(['R', 'G', 'B']):
            self.cache.clear()
            self.hotspots = []
            self.dividir_y_analizar(x, y, w, h, channel=ch)
            if len(self.cache) == 0:
                avg_score = 0
            else:
                avg_score = np.mean([s['score'] for s in self.cache.values()])
            results[name] = {'avg_score': avg_score, 'hotspots': len(self.hotspots)}
            print(f"  Canal {name}: score promedio {avg_score:.3f}, hotspots {len(self.hotspots)}")

        best = max(results.items(), key=lambda kv: kv[1]['avg_score'])
        print(f"\nCanal más sospechoso: {best[0]} (score {best[1]['avg_score']:.3f})")
        self.plot_results(best[0])
        return best

    # ---------------------------------------------------------------
    def extraer_mensaje_lsb(self):
        """Intenta extraer mensaje oculto del canal más sospechoso"""
        print("\nExtrayendo mensaje ...")
        for ch, name in enumerate(['R', 'G', 'B']):
            canal = self.image[:, :, ch]
            bits = canal & 1
            flat_bits = bits.flatten()
            chars = []
            for i in range(0, len(flat_bits), 8):
                byte = flat_bits[i:i+8]
                if len(byte) < 8:
                    break
                valor = int("".join(str(b) for b in byte), 2)
                if valor == 0:
                    break
                if chr(valor) in string.printable:
                    chars.append(chr(valor))
                else:
                    break
            mensaje = "".join(chars)
            if len(mensaje) > 3:
                print(f"Mensaje encontrado en canal {name}:")
                print(f"   {mensaje}")
                return mensaje
        print("No se detectó texto legible.")
        return None


# ===============================================================
# FUNCIÓN PARA CREAR IMAGEN CON MENSAJE OCULTO
# ===============================================================
def create_stego_image_with_patch(msg, output_name="stego.png", size=(200, 200)):
    img = np.zeros((size[1], size[0], 3), dtype=np.uint8) + 200
    binary = ''.join(format(ord(c), '08b') for c in msg) + '00000000'

    bit_index = 0
    for i in range(size[1]):
        for j in range(size[0]):
            if bit_index < len(binary):
                # Canal azul (índice 2) — se oculta aquí
                img[i, j, 2] = (img[i, j, 2] & 0xFE) | int(binary[bit_index])
                bit_index += 1
            else:
                break

    Image.fromarray(img).save(output_name)
    print(f"Imagen creada con mensaje oculto: {output_name}")


# ===============================================================
# MAIN DE PRUEBA
# ===============================================================
if __name__ == "__main__":
    print("============================================================")
    print(" DETECTOR DE MENSAJES OCULTOS (LSB) - Divide y Vencerás")
    print("============================================================")

    opcion = input("1. Crear imagen con mensaje\n2. Analizar imagen\nSelecciona una opción: ")

    if opcion == "1":
        mensaje = input("Ingresa el mensaje a ocultar: ")
        nombre = input("Nombre del archivo (sin extensión): ") or "stego"
        create_stego_image_with_patch(mensaje, output_name=f"{nombre}.png")

    elif opcion == "2":
        path = input("Ruta de la imagen a analizar: ")
        detector = LSBDetectorDVC(path)
        start = time.time()
        best = detector.analyze_all_channels()
        detector.extraer_mensaje_lsb()
        end = time.time()
        print(f"\nTiempo total: {end - start:.2f} segundos")
